"use strict";(self.webpackChunkcerita_di_sekitarmu=self.webpackChunkcerita_di_sekitarmu||[]).push([[327],{327:(e,t,r)=>{r.r(t),r.d(t,{default:()=>s});var o=r(426),n=r(763);const s={render:async()=>(console.log("FavoritesPage: Checking authentication..."),n.y.isLoggedIn()?(console.log("FavoritesPage: User is logged in, rendering favorites..."),'\n      <section class="favorites-page" aria-labelledby="favorites-title">\n        <h1 id="favorites-title" tabindex="0">‚ù§Ô∏è Cerita Favorit Anda</h1>\n        \n        <div class="favorites-controls">\n          <button id="clear-favorites" class="secondary-button">\n            üóëÔ∏è Hapus Semua Favorit\n          </button>\n          <button id="export-favorites" class="secondary-button">\n            üì§ Ekspor Favorit\n          </button>\n        </div>\n        \n        <div id="favorites-list" class="story-list">\n          <p id="loading-favorites">Memuat cerita favorit...</p>\n        </div>\n        \n        <div id="no-favorites" style="display: none; text-align: center; padding: 40px;">\n          <p>Belum ada cerita favorit.</p>\n          <p>Kunjungi <a href="#/beranda" class="link">Beranda</a> untuk menambahkan cerita ke favorit.</p>\n        </div>\n      </section>\n    '):(console.log("FavoritesPage: User not logged in"),'\n        <section class="favorites-page">\n          <h1>Akses Ditolak</h1>\n          <p>Anda harus login untuk mengakses halaman ini.</p>\n          <a href="#/login" class="link">Masuk</a>\n        </section>\n      ')),async afterRender(){console.log("FavoritesPage: afterRender called"),n.y.isLoggedIn()?(console.log("FavoritesPage: Loading favorites..."),await this._loadFavorites(),this._setupControls()):console.log("FavoritesPage: User not logged in in afterRender")},async _loadFavorites(){const e=document.getElementById("favorites-list"),t=document.getElementById("loading-favorites"),r=document.getElementById("no-favorites");try{const n=await o.v.getFavorites();if(t&&t.remove(),0===n.length)return e.style.display="none",void(r.style.display="block");e.innerHTML=n.map((e=>`\n        <article class="story-card favorite-card">\n          <div class="story-header">\n            <h3>${e.name||"Cerita Tanpa Judul"}</h3>\n            <button class="remove-favorite-btn" data-story-id="${e.storyId}"\n                    aria-label="Hapus dari favorit">\n              ‚ùå\n            </button>\n          </div>\n          \n          <img src="${e.photoUrl}" \n               alt="Foto cerita favorit" \n               class="story-photo"\n               loading="lazy">\n               \n          <div class="story-content">\n            <p>${e.description}</p>\n            <div class="story-meta">\n              <small>Ditambahkan: ${new Date(e.addedAt).toLocaleDateString("id-ID")}</small>\n            </div>\n          </div>\n        </article>\n      `)).join(""),this._setupFavoriteInteractions()}catch(t){console.error("Error loading favorites:",t),e.innerHTML="<p>Gagal memuat cerita favorit.</p>"}},_setupControls(){const e=document.getElementById("clear-favorites"),t=document.getElementById("export-favorites");e.addEventListener("click",(()=>this._clearAllFavorites())),t.addEventListener("click",(()=>this._exportFavorites()))},_setupFavoriteInteractions(){document.querySelectorAll(".remove-favorite-btn").forEach((e=>{e.addEventListener("click",(async t=>{const r=e.dataset.storyId;await o.v.removeFavorite(r),this._loadFavorites()}))}))},async _clearAllFavorites(){if(confirm("Apakah Anda yakin ingin menghapus semua cerita favorit?"))try{const e=await o.v.getFavorites();await Promise.all(e.map((e=>o.v.removeFavorite(e.storyId)))),this._loadFavorites(),alert("Semua cerita favorit telah dihapus.")}catch(e){console.error("Error clearing favorites:",e),alert("Gagal menghapus cerita favorit.")}},async _exportFavorites(){try{const e=await o.v.getFavorites();if(0===e.length)return void alert("Tidak ada cerita favorit untuk diekspor.");const t={exportedAt:(new Date).toISOString(),totalFavorites:e.length,favorites:e.map((e=>({title:e.name,description:e.description,photoUrl:e.photoUrl,addedAt:e.addedAt})))},r=new Blob([JSON.stringify(t,null,2)],{type:"application/json"}),n=URL.createObjectURL(r),s=document.createElement("a");s.href=n,s.download=`cerita-favorit-${(new Date).toISOString().split("T")[0]}.json`,document.body.appendChild(s),s.click(),document.body.removeChild(s),URL.revokeObjectURL(n),alert(`Berhasil mengekspor ${e.length} cerita favorit.`)}catch(e){console.error("Error exporting favorites:",e),alert("Gagal mengekspor cerita favorit.")}}}},426:(e,t,r)=>{r.d(t,{v:()=>o});const o=new class{constructor(){this.dbName="CeritaDatabase",this.version=9,this.db=null,this._isOpening=!1,this._openPromise=null}async init(){return this._isOpening||(this._isOpening=!0,this._openPromise=new Promise(((e,t)=>{const r=indexedDB.open(this.dbName,this.version);r.onerror=()=>{this._isOpening=!1,t(r.error)},r.onsuccess=()=>{this.db=r.result,this._isOpening=!1,this.db.onerror=e=>{console.error("Database error:",e.target.error)},this.db.onclose=()=>{console.log("Database connection closed"),this.db=null,this._isOpening=!1},e(this.db)},r.onupgradeneeded=e=>{const t=e.target.result,r=e.oldVersion;if(console.log(`üîÑ Database upgrading from version ${r} to ${this.version}`),r<1){const e=t.createObjectStore("stories",{keyPath:"id"});e.createIndex("createdAt","createdAt",{unique:!1}),e.createIndex("hasLocation","hasLocation",{unique:!1}),e.createIndex("name","name",{unique:!1}),e.createIndex("description","description",{unique:!1});const r=t.createObjectStore("offlineStories",{keyPath:"id",autoIncrement:!0});r.createIndex("createdAt","createdAt",{unique:!1}),r.createIndex("synced","synced",{unique:!1}),t.createObjectStore("favorites",{keyPath:"storyId"}).createIndex("addedAt","addedAt",{unique:!1})}if(r<9){const t=e.target.transaction.objectStore("offlineStories");t.indexNames.contains("synced")||t.createIndex("synced","synced",{unique:!1})}},r.onblocked=()=>{console.log("‚ö†Ô∏è Database upgrade blocked - close other tabs"),this.db&&this.db.close()}}))),this._openPromise}async _ensureDB(){if(this.db)try{const e=this.db.transaction([],"readonly");await new Promise(((t,r)=>{e.oncomplete=t,e.onerror=r}))}catch(e){console.log("Database connection lost, reinitializing..."),this.db=null,await this.init()}else await this.init()}async saveStories(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["stories"],"readwrite"),n=o.objectStore("stories");n.clear(),e.forEach((e=>{n.put({...e,hasLocation:!(!e.lat||!e.lon),cachedAt:(new Date).toISOString()})})),o.oncomplete=()=>t(),o.onerror=()=>r(o.error)}))}catch(e){throw console.error("Error saving stories:",e),e}}async getStories(){try{return await this._ensureDB(),new Promise(((e,t)=>{const r=this.db.transaction(["stories"],"readonly").objectStore("stories").getAll();r.onsuccess=()=>e(r.result||[]),r.onerror=()=>t(r.error)}))}catch(e){return console.error("Error getting stories:",e),[]}}async deleteStory(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["stories"],"readwrite").objectStore("stories").delete(e);o.onsuccess=()=>t(),o.onerror=()=>r(o.error)}))}catch(e){throw console.error("Error deleting story:",e),e}}async saveOfflineStory(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["offlineStories"],"readwrite").objectStore("offlineStories"),n={...e,id:Date.now(),createdAt:(new Date).toISOString(),synced:!1},s=o.add(n);s.onsuccess=()=>t(n.id),s.onerror=()=>r(s.error)}))}catch(e){throw console.error("Error saving offline story:",e),e}}async getOfflineStories(){try{return await this._ensureDB(),new Promise(((e,t)=>{const r=this.db.transaction(["offlineStories"],"readonly").objectStore("offlineStories").getAll();r.onsuccess=()=>e(r.result||[]),r.onerror=()=>t(r.error)}))}catch(e){return console.error("Error getting offline stories:",e),[]}}async deleteOfflineStory(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["offlineStories"],"readwrite").objectStore("offlineStories").delete(e);o.onsuccess=()=>t(),o.onerror=()=>r(o.error)}))}catch(e){throw console.error("Error deleting offline story:",e),e}}async markOfflineStoryAsSynced(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["offlineStories"],"readwrite").objectStore("offlineStories"),n=o.get(e);n.onsuccess=()=>{const s=n.result;if(s){const n="string"==typeof e?parseInt(e):e;s.synced=!0,s.id=n;const a=o.put(s);a.onsuccess=()=>{console.log(`Story ${e} marked as synced`),t()},a.onerror=t=>{console.error(`Error marking story ${e} as synced:`,t),r(t)}}else console.warn(`Story ${e} not found for marking as synced`),t()},n.onerror=t=>{console.error(`Error getting story ${e}:`,t),r(t)}}))}catch(e){throw console.error("Error marking story as synced:",e),e}}async getUnsyncedStories(){try{return await this._ensureDB(),new Promise(((e,t)=>{const r=this.db.transaction(["offlineStories"],"readonly").objectStore("offlineStories").getAll();r.onsuccess=()=>{try{const t=r.result||[];console.log("Total offline stories:",t.length);const o=t.filter((e=>!1===e.synced||void 0===e.synced));console.log("Unsynced stories:",o.length),e(o)}catch(t){console.error("Error filtering stories:",t),e([])}},r.onerror=e=>{console.error("Error getting offline stories:",e),t(e)}}))}catch(e){return console.error("Error in getUnsyncedStories:",e),[]}}async syncOfflineStories(){try{console.log("Starting offline stories sync...");const e=await this.getUnsyncedStories();console.log(`Found ${e.length} stories to sync`);const t={successful:[],failed:[]};if(0===e.length)return console.log("No stories to sync"),t;for(const r of e)try{console.log(`Syncing story ${r.id}...`),await new Promise(((e,t)=>{setTimeout((()=>{Math.random()>.2?e({success:!0,id:r.id}):t(new Error("Sync simulation failed"))}),500)})),await this.markOfflineStoryAsSynced(r.id),t.successful.push(r.id),console.log(`Story ${r.id} synced successfully`)}catch(e){console.error(`Failed to sync story ${r.id}:`,e),t.failed.push({id:r.id,error:e.message})}return console.log("Sync completed:",t),t}catch(e){return console.error("Error in syncOfflineStories:",e),{successful:[],failed:[]}}}async addFavorite(e,t){try{return await this._ensureDB(),new Promise(((r,o)=>{const n=this.db.transaction(["favorites"],"readwrite").objectStore("favorites"),s={storyId:e,...t,addedAt:(new Date).toISOString()},a=n.add(s);a.onsuccess=()=>r(),a.onerror=()=>o(a.error)}))}catch(e){throw console.error("Error adding favorite:",e),e}}async removeFavorite(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["favorites"],"readwrite").objectStore("favorites").delete(e);o.onsuccess=()=>t(),o.onerror=()=>r(o.error)}))}catch(e){throw console.error("Error removing favorite:",e),e}}async getFavorites(){try{return await this._ensureDB(),new Promise(((e,t)=>{const r=this.db.transaction(["favorites"],"readonly").objectStore("favorites").getAll();r.onsuccess=()=>e(r.result),r.onerror=()=>t(r.error)}))}catch(e){return console.error("Error getting favorites:",e),[]}}async isFavorite(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["favorites"],"readonly").objectStore("favorites").get(e);o.onsuccess=()=>t(!!o.result),o.onerror=()=>r(o.error)}))}catch(e){return console.error("Error checking favorite:",e),!1}}async searchStories(e){try{if(console.log("üîç IDBManager: Searching for:",e),!e||""===e.trim())return(await this.getStories()).sort(((e,t)=>new Date(t.createdAt)-new Date(e.createdAt)));const t=await this.getStories(),r=e.toLowerCase().trim();console.log("üîç IDBManager: Total stories to search:",t.length);const o=t.filter((e=>{const t=e.name?.toLowerCase()||"",o=e.description?.toLowerCase()||"";return t.includes(r)||o.includes(r)})).sort(((e,t)=>new Date(t.createdAt)-new Date(e.createdAt)));return console.log("üîç IDBManager: Search results:",o.length),o}catch(e){return console.error("‚ùå IDBManager: Search error:",e),[]}}async filterStories(e={}){try{console.log("üîç IDBManager: Applying filters:",e);let t=await this.getStories();if(console.log("üîç IDBManager: Total stories before filtering:",t.length),e.hasLocation&&(t=t.filter((e=>e.lat&&e.lon)),console.log("üîç IDBManager: After location filter:",t.length)),e.dateRange&&(t=t.filter((t=>{const r=new Date(t.createdAt);return r>=e.dateRange.start&&r<=e.dateRange.end})),console.log("üîç IDBManager: After date filter:",t.length)),e.favoritesOnly){const e=(await this.getFavorites()).map((e=>e.storyId));t=t.filter((t=>e.includes(t.id))),console.log("üîç IDBManager: After favorites filter:",t.length)}return t}catch(e){return console.error("Error filtering stories:",e),[]}}async sortStories(e="createdAt",t="desc",r=null){try{return console.log(`üîç IDBManager: Sorting by ${e} ${t}`),(await this.getStories()).sort(((o,n)=>{let s=o[e],a=n[e];"createdAt"===e&&(s=new Date(s),a=new Date(a));let i=0;if(i=s<a?-1:s>a?1:0,"desc"===t&&(i=-i),0===i&&r){const e=o[r.field],t=n[r.field];let s=0;return e<t?s=-1:e>t&&(s=1),"desc"===r.order?-s:s}return i}))}catch(e){return console.error("Error sorting stories:",e),[]}}async getStats(){try{const e=await this.getStories(),t=await this.getOfflineStories(),r=await this.getFavorites();return{totalStories:e.length,storiesWithLocation:e.filter((e=>e.lat&&e.lon)).length,offlineStories:t.length,unsyncedStories:t.filter((e=>!e.synced)).length,favorites:r.length}}catch(e){return console.error("Error getting stats:",e),{totalStories:0,storiesWithLocation:0,offlineStories:0,unsyncedStories:0,favorites:0}}}async getStoryById(e){try{return await this._ensureDB(),new Promise(((t,r)=>{const o=this.db.transaction(["stories"],"readonly").objectStore("stories").get(e);o.onsuccess=()=>t(o.result),o.onerror=()=>r(o.error)}))}catch(e){return console.error("Error getting story by ID:",e),null}}async getStoriesPaginated(e=1,t=10){try{const r=await this.getStories(),o=(e-1)*t,n=o+t;return{stories:r.slice(o,n),total:r.length,page:e,pageSize:t,totalPages:Math.ceil(r.length/t)}}catch(e){return console.error("Error getting paginated stories:",e),{stories:[],total:0,page:1,pageSize:10,totalPages:0}}}async clearDatabase(){try{return await this._ensureDB(),new Promise(((e,t)=>{const r=this.db.transaction(["stories","offlineStories","favorites"],"readwrite");r.objectStore("stories").clear(),r.objectStore("offlineStories").clear(),r.objectStore("favorites").clear(),r.oncomplete=()=>e(),r.onerror=()=>t(r.error)}))}catch(e){throw console.error("Error clearing database:",e),e}}}}}]);